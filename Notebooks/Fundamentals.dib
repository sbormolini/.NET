#!markdown

Simple delegate samples

Source: abukakmeh.com

#!csharp

var hello = () => Console.WriteLine("Sali ");

hello += () => Console.WriteLine("Basel ");
hello += () => Console.WriteLine(".NET und I!");

hello();

// output:
// Sali Basel, .NET und I!

#!markdown

Exception Filters to allow catch blocks targeting specific exceptions.

Source: abukakmeh.com

#!csharp

using System.Net;

try
{
    var client = new HttpClient();
    var result  = await client.GetAsync("https://httpstat.us/404");
    result.EnsureSuccessStatusCode();
}
catch (HttpRequestException hre) when (hre.StatusCode == HttpStatusCode.NotFound)
{
    Console.WriteLine("Oh no not found!");
}

#!markdown

What is deconstruct in C#?
Deconstruction is a process of splitting a variable value into parts and storing them into new variables. 
This could be useful when a variable stores multiple values such as a tuple. Let's take a look at the code sample in Listing 1. In this code, method GetATuple returns a tuple with three values.

Source: abukakmeh.com

#!csharp

var (year, month, day) = DateTime.Now;
Console.WriteLine($"It's now {day} {month} {year}!");

public static class DateTimeExtensions
{
    // Deconstruct name is important
    public static void Deconstruct(this DateTime dateTime, out int year, out int month, out int day) =>
        (year, month, day) = (dateTime.Year, dateTime.Month, dateTime.Day);
}

#!markdown

Minimal APIs service
Minimal APIs use ASP.NET Core dependency injection services to manages dependencies. You can register services with varyjing lifetimes, such a transient, scoped or singleton.

Source: abukakmeh.com

#!csharp

var builder = WebApplication.CreateBuiler(args);

// register service for use in endpoints
// scoped : created for each incoming reqzest
builder.Services.AddScoped<MyService>();
var app = builder.Build();

// my service injected using ASP.NET Core DI
app.MapGet("/",(MyService myService) => myService.Hi);

app.Run();

public class MyService 
{
    public string Hi => "GrÃ¼ezi!";
}

#!markdown

Pattern matching in C# allows matching on things that implement ITuple

Source: https://twitter.com/19481808/status/1507043438037909504

#!csharp

{
    object o = new Person();
    
    if (o is var (name, age))
    {
        Console.WriteLine($"Name: {name}, Age: {age}");
    }
}

{
    object o = new Person();
    
    if (o is (string name, int age))
    {
        Console.WriteLine($"Name: {name}, Age: {age}");
    }
}

class Person : ITuple
{
    public object? this[int index] => index switch 
    {
        0 => "SomeName",
        1 => 35,
        _ => null
    };

    public int Length => 2;
}

#!markdown

Explore lazy initialization in .NET, a performance improvement that means an object creation is deferred until the object is first used

#!csharp

// target type expression for defining lazy

private static readonly Lazy<Font> = FontValue = new(() => {
    FontCollection collcetion = new();
    var familiy = collection.Add("./assets/FontName.ttf");
    return familiy.CreateFont(FontSize, FontStyle.Bold);
});

#!markdown

Represents the largest possible value of an Int32. This field is constant.
https://docs.microsoft.com/en-us/dotnet/api/system.int32.maxvalue?view=net-6.0

Represents the smallest possible value of Int32. This field is constant.
https://docs.microsoft.com/en-us/dotnet/api/system.int32.minvalue?view=net-6.0

#!csharp

// arbitary
var large = 1_000_000;

// top most limiz of int
var largest = int.MaxValue;

// bottom most limiz of int
var smallest = int.MinValue;

#!markdown

Anonymous Types
https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/anonymous-types

#!csharp

// anonymous type
var v = new { 
    Amount = 108, 
    Message = "Hello" 
};

// Rest the mouse pointer over v.Amount and v.Message in the following
// statement to verify that their inferred types are int and string.
Console.WriteLine(v.Amount + v.Message);

#!csharp

var productQuery =
    from prod in products
    select new { prod.Color, prod.Price };

foreach (var v in productQuery)
{
    Console.WriteLine("Color={0}, Price={1}", v.Color, v.Price);
}

#!csharp

var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};
