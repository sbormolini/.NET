#!markdown

Simple delegate samples

Source: abukakmeh.com

#!csharp

var hello = () => Console.WriteLine("Sali ");

hello += () => Console.WriteLine("Basel ");
hello += () => Console.WriteLine(".NET und I!");

hello();

// output:
// Sali Basel, .NET und I!

#!markdown

Exception Filters to allow catch blocks targeting specific exceptions.

Source: abukakmeh.com

#!csharp

using System.Net;

try
{
    var client = new HttpClient();
    var result  = await client.GetAsync("https://httpstat.us/404");
    result.EnsureSuccessStatusCode();
}
catch (HttpRequestException hre) when (hre.StatusCode == HttpStatusCode.NotFound)
{
    Console.WriteLine("Oh no not found!");
}

#!markdown

What is deconstruct in C#?
Deconstruction is a process of splitting a variable value into parts and storing them into new variables. 
This could be useful when a variable stores multiple values such as a tuple. Let's take a look at the code sample in Listing 1. In this code, method GetATuple returns a tuple with three values.

Source: abukakmeh.com

#!csharp

var (year, month, day) = DateTime.Now;
Console.WriteLine($"It's now {day} {month} {year}!");

public static class DateTimeExtensions
{
    // Deconstruct name is important
    public static void Deconstruct(this DateTime dateTime, out int year, out int month, out int day) =>
        (year, month, day) = (dateTime.Year, dateTime.Month, dateTime.Day);
}

#!markdown

Minimal APIs service
Minimal APIs use ASP.NET Core dependency injection services to manages dependencies. You can register services with varyjing lifetimes, such a transient, scoped or singleton.

Source: abukakmeh.com

#!csharp

var builder = WebApplication.CreateBuiler(args);

// register service for use in endpoints
// scoped : created for each incoming reqzest
builder.Services.AddScoped<MyService>();
var app = builder.Build();

// my service injected using ASP.NET Core DI
app.MapGet("/",(MyService myService) => myService.Hi);

app.Run();

public class MyService 
{
    public string Hi => "Grüezi!";
}

#!markdown

Pattern matching in C# allows matching on things that implement ITuple

Source: https://twitter.com/19481808/status/1507043438037909504

#!csharp

{
    object o = new Person();
    
    if (o is var (name, age))
    {
        Console.WriteLine($"Name: {name}, Age: {age}");
    }
}

{
    object o = new Person();
    
    if (o is (string name, int age))
    {
        Console.WriteLine($"Name: {name}, Age: {age}");
    }
}

class Person : ITuple
{
    public object? this[int index] => index switch 
    {
        0 => "SomeName",
        1 => 35,
        _ => null
    };

    public int Length => 2;
}

#!markdown

Explore lazy initialization in .NET, a performance improvement that means an object creation is deferred until the object is first used

#!csharp

// target type expression for defining lazy

private static readonly Lazy<Font> = FontValue = new(() => {
    FontCollection collcetion = new();
    var familiy = collection.Add("./assets/FontName.ttf");
    return familiy.CreateFont(FontSize, FontStyle.Bold);
});

#!markdown

Represents the largest possible value of an Int32. This field is constant.
https://docs.microsoft.com/en-us/dotnet/api/system.int32.maxvalue?view=net-6.0

Represents the smallest possible value of Int32. This field is constant.
https://docs.microsoft.com/en-us/dotnet/api/system.int32.minvalue?view=net-6.0

#!csharp

// arbitary
var large = 1_000_000;

// top most limiz of int
var largest = int.MaxValue;

// bottom most limiz of int
var smallest = int.MinValue;

#!markdown

Anonymous Types
https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/anonymous-types

#!csharp

// anonymous type
var v = new { 
    Amount = 108, 
    Message = "Hello" 
};

// Rest the mouse pointer over v.Amount and v.Message in the following
// statement to verify that their inferred types are int and string.
Console.WriteLine(v.Amount + v.Message);

#!csharp

var productQuery =
    from prod in products
    select new { prod.Color, prod.Price };

foreach (var v in productQuery)
{
    Console.WriteLine("Color={0}, Price={1}", v.Color, v.Price);
}

#!csharp

var anonArray = new[] { new { name = "apple", diam = 4 }, new { name = "grape", diam = 1 }};

#!markdown

define class that lets callers subscribe to an event in c#
https://dotnet.github.io/orleans/docs/tutorials_and_samples/tutorial_1.html

#!csharp

// version 1
class MyThing
{
    public event Action OnThing { get; set; }

    public void DoThing()
    {
        OnThing?.Invoke();
    }
}

#!csharp

// version 2
class MyThing
{
    private List<Action> _subscribers = new();

    public void DoThing()
    {
        foreach (var s in _subscribers)
        {
            s();
        }
    }

    public void Subscribe(Action callback)
    {
        _subscribers.Add(callback);
    }

    public void Unsubscribe(Action callback)
    {
        _subscribers.Remove(callback);
    }
}

#!csharp

// version 3

interface IThingSubscriber
{
    void OnThingDone();
}

class MyThing
{
    private List<IThingSubscriber> _subscribers = new();

    public void DoThing()
    {
        foreach (var s in _subscribers)
        {
            s.OnThingDone();
        }
    }

    public void Subscribe(IThingSubscriber subscriber)
    {
        _subscribers.Add(subscriber);
    }

    public void Unsubscribe(IThingSubscriber subscriber)
    {
        _subscribers.Remove(subscriber);
    }
}

#!markdown

Discard Arguments

#!csharp

using static System.Diagnostics.Process;

//dont need or want the value
var isNumber = int.TryParse("one", out var _);
Console.WriteLine(isNumber);

// dont need these args
var process = Start("ping", "localhost -c 1");
process.Exited += (_, _) => Console.WriteLine("done!");
await process.WaitForExitAsync();

#!markdown

Caching in .NET applications
https://docs.microsoft.com/en-us/dotnet/api/system.runtime.caching?view=dotnet-plat-ext-6.0

The cache provides you mechanisms to cache and expires in-memory objects for improved preformance and memory management.

#!csharp

// #nuget System.Runtime.Caching
using System.Runtime.Caching;
using static System.DateTimeOffset;

var cache = MemoryCache.Default;

cache.Add(
    key: "91346c29-45b4-4420-9d08-1b5f793f88f9",
    value: "{\"name\":\"John\", \"age\":30, \"car\":null}",
    absoluteExpiration: Now.AddSeconds(60)
);

#!markdown

Writing to a file
https://docs.microsoft.com/en-us/dotnet/api/system.io?view=net-6.0

#!csharp

using System.IO;
using static System.IO.FileMode;

using var file = File.Open("test.txt", OpenOrCreate);

using var writer = new StreamWriter(file);

await writer.WriteLineAsync("This is a test");

#!markdown

# Cancel Running Tasks
Long-running tasks may never end on their own.
To stop a task, you ca use "CancellationTokenSource" and CancelleationToken".

https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken?view=net-6.0
https://docs.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource?view=net-6.0

#!csharp

using static System.Console;

var source = new CancellationTokenSource();
var token = source.Token;

Task.Run(async () => {
    while(true)
    {
        WriteLine("RUNNING");
        var wait = TimeSpan.FromSeconds(1);
        await Task.Delay(wait, token);
    }
}, token);

ReadKey();
// stop running the task
source.Cancel();
WriteLine("Cancelled!");
ReadKey();

#!markdown

# uri builder
The UriBuilder class provides a convenient way to modify the contents of a Uri instance without creating a new Uri instance for each modification.
The UriBuilder properties provide read/write access to the read-only Uri properties so that they can be modified.

https://docs.microsoft.com/en-us/dotnet/api/system.uribuilder?view=net-6.0

#!csharp

var host = "www.contosoe.com";
var port = 80;
var page = "default.html";
var qs = "records=10";

// string
string path = $"https://{host}:{port}/{page}?{qs}";
//path => https://www.contosoe.com:80/default.html?records=10

// uribuilder
UriBuilder baseUri = new("https", host, 80, page, qs);
//baseUri.Host => www.contosoe.com
//baseUri.Port => 80
//baseUri.Query => ?records=10
//baseUri => https://www.contosoe.com:80/default.html?records=10

#!markdown

# Filters in Minimal API apps
Minimal API filters allow developers to implement business logic that supports:

Running code before and after the endpoint handler.
Inspecting and modifying parameters provided during an endpoint handler invocation.
Intercepting the response behavior of an endpoint handler.
Filters can be helpful in the following scenarios:

Validating the request parameters and body that are sent to an endpoint.
Logging information about the request and response.
Validating that a request is targeting a supported API version.

#!csharp

var builder = WebApplication.CreateBuilder(args);

var app = builder.Build();

string ColorName(string color) => $"Color specified: {color}!";

app.MapGet("/colorSelector/{color}", ColorName)
    .AddEndpointFilter(async (invocationContext, next) =>
    {
        var color = invocationContext.GetArgument<string>(0);

        if (color == "Red")
        {
            return Results.Problem("Red not allowed!");
        }
        return await next(invocationContext);
    });

app.Run();

#!markdown

Beginning with C# 11, the interpolated expressions can include newlines. The text between the { and } must be valid #csharp, therefore it can include newlines that improve readability
https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated

#!csharp

int safetyScore = 91;

string message = $"The usage policy for {safetyScore} is {
    safetyScore switch
    {
        > 90 => "Unlimited usage",
        > 80 => "General usage, with daily safety check",
        > 70 => "Issues must be adresses within 1 week",
        > 50 => "Issues must be adresses within 1 day",
        _ => "Issues must be addressed before continued use",
    }
}";

Console.WriteLine(message); 

#!markdown

# Enhanced Pattern Matching
C#9 enhances pattern matching with additional keywords: and, or, & not.
You can build powerful pattern-matching expressions combined with the "is" keyword.<br>
Source: @buhakmeh

https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/pattern-matching 

#!csharp

var value = 'k';
var result = IsLetterOrSeperator(value);

// k : True
Console.WriteLine($"{value} : {result}");

bool IsLetterOrSeperator(char c) => 
    c is (>= 'a' and <= 'z') 
    or (>= 'A' and <= 'Z')
    or '.'
    or ','
    and not ' ';

#!markdown

# Exception and Stack Traces
You need to be careful when re-throwing exceptions.<br>
Throwing an exception explicitly reset the stack trace and can make it difficult to track down the real issue.<br>
Source: @buhakmeh

#!csharp

try { A(); }
catch (Exception e)
{
    throw e;
}

static void A() => B();
static void B() => C();
static void C() => throw new NotImplementedException();

#!markdown

### AsyncLocal< T > Class<br>
Represents ambient data that is local to a given asynchronous control flow, such as an asynchronous method.<br>
Sources:<br>
https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-6.0
https://docs.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1?view=net-6.0

#!csharp

var local = new AsyncLocal<int>();

Console.WriteLine($"Before: {local.Value}");
await Bleed();
Console.WriteLine($"After: {local.Value}");

Task Bleed()
{
    local.Value = 10;
    return Task.CompletedTask;
}

#!markdown

### Out Parameters
Out parameters allow you to return conditional values to the caller.<br>
Here you can see a string being parsed and its integer value is used to ouput the result.<br>
Source: @buhakmeh<br>
<br>
https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/out-parameter-modifier

#!csharp

using static System.Console;

// use the out value if result
// when the string value
// is successfully parsed
if (int.TryParse("42", out var result))
{
    WriteLine($"the answer is {result}");
}

#!markdown

### Expression Bodied Members
When creating get-only convenience members that rely on toher properties in your object, consider using expression-bodied members.
Significantly reduce noise in your type declarations.
Source: @buhakmeh<br>
<br>
https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members

#!csharp

var noRobot = new Person("Sandro", "Bormolini");

Console.WriteLine(noRobot.FullName);

// new implementation
public record Person(string FirstName, string LastName)
{
    public string FullName => $"{FirstName} {LastName}";
}

/* old
public record Person(string FirstName, string LastName)
{
    public string FullName { 
        get { return $"{FirstName} {LastName}" }
    }
}
*/

#!markdown

### ClientWebSocket upgrade response details
ClientWebSocket previously did not provide any details about upgrade response. However, the information about response headers and status code might be important in both failure and success scenarios.

dotnet/runtime#25918
https://github.com/dotnet/runtime/issues/25918

#!csharp

ClientWebSocket ws = new();
ws.Options.CollectHttpResponseDetails = true;
try
{
    await ws.ConnectAsync(uri, default);
    // success scenario
    ProcessSuccess(ws.HttpResponseHeaders);
    ws.HttpResponseHeaders = null; // clean up (if needed)
}
catch (WebSocketException)
{
    // failure scenario
    if (ws.HttpStatusCode != null)
    {
        ProcessFailure(ws.HttpStatusCode, ws.HttpResponseHeaders);
    }
}

#!markdown

### System.Math
Provides constants and static methods for trigonometric, logarithmic, and other common mathematical functions.<br>
https://docs.microsoft.com/en-us/dotnet/api/system.math?view=net-7.0 
<br>
Code source: @buhakmeh<br>
<br>

#!csharp

using static System.Console;
using static System.Math;

var inches = 12;
var radius = inches / 2;
var pizza = (PI * Pow(radius, 2));

// results
WriteLine($"You have {pizza:00.00} in²");

#!markdown

### sealed class
When applied to a class, the sealed modifier prevents other classes from inheriting from it. Should be applied by default! Also benefits from performance improvments.<br>
Reference: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/sealed<br>
Source: https://www.youtube.com/watch?v=d76WWAD99Yo&t=1s (Nick Chapsas)<br>

#!csharp

public class BaseClass
{
    public virtual void ExampleVoidMethod() {}
    public virtual int ExampleIntMethod() => 0;
}

public class OpenClass : BaseClass
{
    public override void ExampleVoidMethod() {}
    public override int ExampleIntMethod() => 69;
}

// better performance, use as default
public sealed class SealedClass : BaseClass
{
    public override void ExampleVoidMethod() {}
    public override int ExampleIntMethod() => 420;
}

#!markdown

### Iterate List
Gets a Span<T> view over the data in a list. Items should not be added or removed from the List<T> while the Span<T> is in use.<br>
Source: https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.collectionsmarshal.asspan?view=net-6.0<br>
Code source: https://www.youtube.com/watch?v=jUZ3VKFyB-A (Nick Chapsas)

#!csharp

Random rng  = new(420);
int size = 100;
List<int> _items;

_items = Enumerable.Range(1, size).Select(x => rng.Next()).ToList();

// for loop
for (var i = 0; i < _items.Count; i++)
{
    var item = _items[i];
}

// foreach
foreach (var item in _items)
{

}

// foreach lower
List<int>.Enumerator enumerator = _items.GetEnumerator();
try
{
    while (enumerator.MoveNext())
    {
        int current = enumerator.Current;
    }
}
finally
{
    ((IDisposable)enumerator).Dispose();
}

// parallel foreach
Parallel.ForEach(_items, i => {});

// parallel linq
_items.AsParallel().ForAll(i => {});

// foreach span
foreach (var item in CollectionMarshal.AsSpan(_items))
{

}

// for span
var asSpan = CollectionMarshal.AsSpan(_items);
for (var i = 0; i < asSpan.Length; i++)
{
    var item = asSpan[i];
}

#!markdown

### Initalize empty enumerables
Use Enumerable.Empty to initialize an enumerable variable to an empty collection.
<br><br>
Source: https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.empty?view=net-6.0<br>
Code source: @buhakmeh

#!csharp

// dont
IEnumerable<int> integers = null;

// do
IEnumerable<int> numbers = Enumerable.Empty<int>();

// safe access
Console.WriteLine(numbers.Count());

#!markdown

#### Date and Time in C#
Using datetime provider to test code using date and time
https://learn.microsoft.com/en-us/dotnet/api/system.datetime?view=net-7.0
<br><br>
Code source: https://www.youtube.com/watch?v=5DrGdyxnO5A (Nick Chapsas)

#!csharp

// how to test code?

public interface IDateTimeProvdier
{
    public DateTimeOffset Now { get; }
}

pulbic class DateTimeProvider : IDateTimeProvdier
{
    public DateTimeOffset Now  => DateTimeOffset.Now;
}

public class GreeterService
{
    private readonly DateTimeProvider _dateTimeProvider;

    public GreeterService (IDateTimeProvider dateTimeProvider)
    {
        _dateTimeProvider = dateTimeProvider;
    }

    public string GenereateGreetText()
    {
        var dateTimeNow = DateTimeOffset.Now;
        return dateTimeNow.Hour switch
        {
            >= 5 and < 12 => "Morning",
            >= 12 and < 18 => "Good afternoon",
            _ => "Good evening"
        };
    }
}

#!markdown

#### Math.Clamp
Returns value clamped to the inclusive range of min and max.
<br><br>
Source: https://learn.microsoft.com/en-us/dotnet/api/system.math.clamp?view=net-6.0<br>
Code source: @buhajmeh<br>

#!csharp

var extreme = 1000;
var result = Math.Clamp(extreme, 1, 100);

// result is 100
Console.WriteLine(result);

#!markdown

#### CultureInfo TextInfo.ToTitleCase(String)
Converts the specified string to title case (except for words that are entirely in uppercase, which are considered to be acronyms).
<br><br>
Source: https://learn.microsoft.com/en-us/dotnet/api/system.globalization.textinfo.totitlecase?view=net-6.0<br>
Code source: @buhajmeh<br>

#!csharp

using static System.Console;
using static System.Globalization.CultureInfo;

var name = "sandro bormolini";

var info = GetCultureInfo("de-ch").TextInfo;
var result = info.ToTitleCase(name);

WriteLine(result);

#!markdown

#### catch when expression
https://learn.microsoft.com/de-de/dotnet/csharp/language-reference/keywords/try-catch<br>
Code source: @MilanJovanovic

#!csharp

using System.Net;
using System.Net.Http;

var httpClient = new HttpClient();

try 
{
    await httpClient.PutAsync("update-dotnet-tips", tip);
}
catch (HttpRequestException e) when (e.StatusCode == HttpStatusCode.BadRequest)
{
    // handle 400 bad request
}
catch (HttpRequestException e) when (e.StatusCode == HttpStatusCode.NotFound)
{
    // handle 404 not found
}
catch (HttpRequestException e) when (e.StatusCode == HttpStatusCode.Conflict)
{
    // handle 409 conflict
}

#!markdown

Code source: @davidpine7
<br><br>
When iterating with foreach, you can select the index using the Select extension overload. In this example, we deconstruct the index and value, writing them to the console while employing C# 11 raw string literals.

#!csharp

using System;
using System.Linq;

string[] numberNames = {"one", "two", "three", "four"};

foreach (var (index, name) in numberNames.Select((n, i) => (i, n)))
{
    Console.WriteLine($"Index {index}, Value: {name}");
}

#!markdown

#### Using records for Data Transfer Objects (DTO)<br>
https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record<br>
https://learn.microsoft.com/en-us/aspnet/web-api/overview/data/using-web-api-with-entity-framework/part-5<br>

#!csharp

// class
public record ProductResponseAsClass
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Category { get; set; }
    public decimal Price { get; set; }
    public int Quantitiy { get; set; }
}

// record
public record ProductResponseAsRecord(
    int Id,
    string Name, 
    string Category,
    decimal Price,
    int Quantitiy
);

#!markdown

Adding Microseconds and Nanoseconds to TimeStamp, DateTime, DateTimeOffset, and TimeOnly<br>
https://devblogs.microsoft.com/dotnet/announcing-dotnet-7-preview-4/

#!csharp

DateTime demo = DateTime.Now;

Console.WriteLine($"Ticks: {demo.Ticks}");
Console.WriteLine($"Microseconds: {demo.Microsecond}");
Console.WriteLine($"Nanoseconds: {demo.Nanosecond}");

#!markdown

TarFile Class
https://learn.microsoft.com/en-us/dotnet/api/system.formats.tar?view=net-7.0
https://learn.microsoft.com/en-us/dotnet/api/system.formats.tar.tarfile?view=net-7.0

#!csharp

using System.Formats.Tar;

// create tar file
TarFile.CreateFromDirectory(
    @"C:\Temp\Demo\Source",
    @"C:\Temp\Demo\Demo.tar",
    false);

// extract tar file
TarFile.ExtractToDirectory(
    @"C:\Temp\Demo\Demo.tar",
    @"C:\Temp\Demo\Extracted",
    false);

#!markdown

### Code Readability improvments
#### Target typed new expression
Code Source: @MilanJovanovic

#!csharp

var dictionary = new Dictionary<string, List<int>>()
{
    { "one-two", new List<int> {1, 2} },
    { "one-two-three", new List<int> {1, 2, 3} },
};

#!csharp

Dictionary<string, List<int>> dictionary = new()
{
    { "one-two", new() {1, 2} },
    { "one-two-three", new() {1, 2, 3} },
};

#!markdown

#### inline using statement

#!csharp

using System.IO;

public void DoWork()
{
    using (var memoryStream = new MemoryStream())
    {
        // do work with memoryStream
    }
}

#!csharp

using System.IO;

public void DoWork()
{
    using var memoryStream = new MemoryStream();
    // do work with memoryStream
}

#!markdown

#### logic operator

#!csharp

var number = 69;
if (number == 1 || number == 3)
{
    Console.WriteLine("Number is 1 or 3");
}

#!csharp

var number = 69;
if (number is 1 or 3)
{
    Console.WriteLine("Number is 1 or 3");
}
